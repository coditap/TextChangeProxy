package main.java;import java.io.BufferedOutputStream;import java.io.IOException;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import org.apache.log4j.Logger;public class ProxyHTTPSession extends Thread {	private static final Logger LOG = Logger.getLogger(ProxyHTTPSession.class);	public static final int SC_OK = 0;	public static final int SC_CONNECTING_TO_HOST = 1;	public static final int SC_HOST_NOT_FOUND = 2;	public static final int SC_CLIENT_ERROR = 4;	public static final int SC_INTERNAL_SERVER_ERROR = 5;	public static final int SC_NOT_SUPPORTED = 6;	public static final int SC_CONNECTION_CLOSED = 8;	public static final int SC_MOVED_PERMANENTLY = 11;	private static ProxyServer server;	public InetAddress serveraddress;	/** downstream connections */	private Socket client;	private BufferedOutputStream out;	private ProxyClientInputStream in;	/** upstream connections */	private Socket HTTP_Socket;	private BufferedOutputStream HTTP_out;	private ProxyServerInputStream HTTP_in;	public ProxyHTTPSession(ProxyServer server, Socket client) {		try {			in = new ProxyClientInputStream(server, this, client.getInputStream()); // strumien od klienta			out = new BufferedOutputStream(client.getOutputStream()); // strumien do klienta			ProxyHTTPSession.server = server; // przypisanie aktualnego serwera			this.client = client; // i podmiana klinta		} catch (IOException e_io) {			try {				// e_io.printStackTrace();				client.close();			} catch (IOException e_io2) {				// e_io2.printStackTrace();			}			return;		}		try {			serveraddress = InetAddress.getLocalHost(); // adres serwera proxy - localhost		} catch (UnknownHostException e_u_host) {			return;		}		start(); // odapamy watek	}	public Socket getLocalSocket() {		return client;	}	public Socket getRemoteSocket() {		return HTTP_Socket;	}	public boolean isTunnel() {		return in.isTunnel();	}	public boolean notConnected() {		return HTTP_Socket == null;	}	/**	 * metoda do wysylana naglowka	 */	public void sendHeader(int a, boolean b) throws IOException {		sendHeader(a); // wyslanie naglowka z odpowedni kodem		endHeader(); // zakoneczenie naglowka		out.flush(); // przepchanie bufora do strumienia	}	public void sendHeader(int status, String content_type, long content_length) throws IOException {		sendHeader(status); // wysylamy odpowedni stratus		sendLine("Content-Length", String.valueOf(content_length)); // dlugosc contentu		sendLine("Content-Type", content_type); // typ contentu	}	public void sendLine(String s) throws IOException {		write(out, s + "\r\n"); // wysylamy linie oraz znak konca lini	}	public void sendLine(String header, String s) throws IOException {		String line = header + ": " + s + "\r\n"; // tworzymy linie do wyslania		sendLine(line); // wysylamy	}	public void endHeader() throws IOException {		write(out, "\r\n"); // wysylamy znaki konczace naglowek	}	/**	 * glowna metoda	 */	public void run() {		try {			handleRequest(); // przetwarzamy zapytanie		} catch (IOException e_handleRequest) {		} catch (Exception e) {			e.printStackTrace();		}		try {			// close downstream connections			in.close();			out.close();			client.close();			// close upstream connections (webserver or other proxy)			if (!notConnected()) {				HTTP_Socket.close();				HTTP_out.close();				HTTP_in.close();			}		} catch (IOException e_run) {		}	}	/** sends a message to the user */	public void sendErrorMSG(int a, String info) throws IOException {		String msg = "Request failed";		sendLine("Content-Length", String.valueOf(msg.length()));		sendLine("Content-Type", "text/html; charset=utf-8");		endHeader();		write(out, msg);		out.flush();	}	public String sendHeader(int a) throws IOException {		String stat;		switch (a) {		case 200:			stat = "200 OK";			break;		case 202:			stat = "202 Accepted";			break;		case 300:			stat = "300 Ambiguous";			break;		case 301:			stat = "301 Moved Permanently";			break;		case 400:			stat = "400 Bad Request";			break;		case 401:			stat = "401 Denied";			break;		case 403:			stat = "403 Forbidden";			break;		case 404:			stat = "404 Not Found";			break;		case 405:			stat = "405 Bad Method";			break;		case 413:			stat = "413 Request Entity Too Large";			break;		case 415:			stat = "415 Unsupported Media";			break;		case 501:			stat = "501 Not Implemented";			break;		case 502:			stat = "502 Bad Gateway";			break;		case 504:			stat = "504 Gateway Timeout";			break;		case 505:			stat = "505 HTTP Version Not Supported";			break;		default:			stat = "500 Internal Server Error";		}		sendLine(server.getHttpVersion() + " " + stat);		if (a == 501)			sendLine("Allow", "GET, HEAD, POST, PUT, DELETE, CONNECT");		sendLine("Cache-Control", "no-cache, must-revalidate");		sendLine("Connection", "close");		return stat;	}	/** the main routine, where it all happens */	public void handleRequest() throws Exception {		InetAddress remote_host;		ProxyReader remote_in = null;		int remote_port;		byte[] b = new byte[65536]; // inicjalizacja bufora		int numread = in.read(b); // wczytujemy ze strumienia do bufora		while (true) { // with this loop we support persistent connections			if (numread == -1) { // -1 signals an error				if (in.getStatusCode() != SC_CONNECTING_TO_HOST) {					switch (in.getStatusCode()) {					case SC_CONNECTION_CLOSED:						break;					case SC_MOVED_PERMANENTLY:						sendHeader(301);						write(out, "Location: " + in.getErrorDescription() + "\r\n");						endHeader();						out.flush();					default:					}					break; // return from main loop.				} else { // also an error because we are not connected (or to							// the wrong host)							// Creates a new connection to a remote host.					if (!notConnected()) {						try {							HTTP_Socket.close();						} catch (IOException e_close_socket) {						}					}					numread = in.getHeaderLength(); // get the header length					remote_host = in.getRemoteHost(); // pobieramy adres zdalengo hosta					remote_port = in.remotePort; // pobieramy zdalny port					try {						connect(remote_host, remote_port); // laczymy sie z hostem					} catch (IOException e_connect) {						sendErrorMSG(502, "Error while creating a TCP connection to [" + remote_host.getHostName() + ":" + remote_port								+ "] <BR>The proxy server cannot connect to the given address or port [" + e_connect.toString() + "]");						break;					} catch (Exception e) {						sendErrorMSG(500, "Error: " + e.toString());						break;					}					HTTP_out.write(b, 0, numread); // do strunmienia wypisujemy wczytane dane					HTTP_out.flush(); // przepychamy					// read the data from the remote server					if (remote_in != null) {						remote_in.close(); // close thread					}					remote_in = new ProxyReader(this, HTTP_in, out, in); // tworzymy obiekt, ktory odczytuje odpowiedz serwera i przepycha do klienta				}			}			while (true) { // reads data from the client				numread = in.read(b); // wczytujemy dane ze strumienia do b				if (numread != -1) { // jesli nie bylo bledu					HTTP_out.write(b, 0, numread); // dane wypychamy do klienta					HTTP_out.flush(); // przepychamy				} else					break; // w przeciwnym przypadku wychodzimy z nieskonczonej petli			} // end of inner loop for data transfer		}// end of main loop		out.flush();		if (!notConnected() && remote_in != null)			remote_in.close(); // ubijamy strumien, jesli klien nie jest polaczony		return;	}	/** laczenie sie z zadanym hostem i portem */	public void connect(InetAddress host, int port) throws IOException {		HTTP_Socket = new Socket(host, port); // nowy socket z zadanym adresem		HTTP_in = new ProxyServerInputStream(server, HTTP_Socket.getInputStream(), false); // strumien danych wejsciowych		HTTP_out = new BufferedOutputStream(HTTP_Socket.getOutputStream()); // strumien danych wyjsciowych	}	/** pisze stringa do strumienia */	public void write(BufferedOutputStream o, String p) throws IOException {		o.write(p.getBytes(), 0, p.length());	}	/*	 * 8 zwraca status	 */	public int getStatus() {		return in.getStatusCode();	}}